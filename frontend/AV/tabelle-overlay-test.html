<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>OCOSO MVP – Tabelle mit Filter & Diagramm-Overlay</title>
  <!-- Chart.js einbinden -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Basis-Stile */
    body { font-family: sans-serif; margin: 20px; }
    .filter-container { margin-bottom: 20px; }
    .filter-container label { margin-right: 5px; }
    .filter-container select { margin-right: 20px; }
    
    /* Tabellen-Stile */
    .data-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
    .data-table th, .data-table td { border: 1px solid #ccc; padding: 8px; }
    .data-table th { background: #f0f0f0; vertical-align: middle; white-space: nowrap; }
    .data-table td { white-space: nowrap; }
    
    /* Sortier-Icons im Header */
    .sort-icon-container { margin-left: 5px; display: inline-block; vertical-align: middle; }
    .sort-icon-container img { width: 15px; height: 15px; }
    
    /* Overlay-Box für Diagramm */
    #chartOverlay {
      display: none;
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      border-radius: 4px;
    }
  </style>
</head>
<body>

  <!-- Filter-Container -->
  <div class="filter-container">
    <label for="filterTopic">Filter Topics:</label>
    <select id="filterTopic">
      <option value="">Alle</option>
    </select>

    <label for="filterMonetization">Filter Monetization:</label>
    <select id="filterMonetization">
      <option value="">Alle</option>
    </select>

    <label for="filterType">Filter Type:</label>
    <select id="filterType">
      <option value="">Alle</option>
    </select>
  </div>

  <!-- Tabelle -->
  <table class="data-table">
    <thead class="table-header">
      <tr class="header-row">
        <th class="header-cell" data-sort-key="Asset_ID">
          <span>IP-NFT</span>
          <span class="sort-icon-container">
            <img src="img/neutral-icon.png" alt="Nicht sortiert" class="sort-icon neutral" />
            <img src="img/arrow-up.png" alt="Aufsteigend" class="sort-icon up" style="display:none" />
            <img src="img/arrow-down.png" alt="Absteigend" class="sort-icon down" style="display:none" />
          </span>
        </th>
        <th class="header-cell" data-sort-key="Type">
          <span>Typ</span>
          <span class="sort-icon-container">
            <img src="img/neutral-icon.png" alt="Nicht sortiert" class="sort-icon neutral" />
            <img src="img/arrow-up.png" alt="Aufsteigend" class="sort-icon up" style="display:none" />
            <img src="img/arrow-down.png" alt="Absteigend" class="sort-icon down" style="display:none" />
          </span>
        </th>
        <th class="header-cell" data-sort-key="Topics">
          <span>Topics</span>
          <span class="sort-icon-container">
            <img src="img/neutral-icon.png" alt="Nicht sortiert" class="sort-icon neutral" />
            <img src="img/arrow-up.png" alt="Aufsteigend" class="sort-icon up" style="display:none" />
            <img src="img/arrow-down.png" alt="Absteigend" class="sort-icon down" style="display:none" />
          </span>
        </th>
        <th class="header-cell" data-sort-key="Monetization">
          <span>Monetization</span>
          <span class="sort-icon-container">
            <img src="img/neutral-icon.png" alt="Nicht sortiert" class="sort-icon neutral" />
            <img src="img/arrow-up.png" alt="Aufsteigend" class="sort-icon up" style="display:none" />
            <img src="img/arrow-down.png" alt="Absteigend" class="sort-icon down" style="display:none" />
          </span>
        </th>
        <th class="header-cell" data-sort-key="Start_Date">
          <span>Start-Date</span>
          <span class="sort-icon-container">
            <img src="img/neutral-icon.png" alt="Nicht sortiert" class="sort-icon neutral" />
            <img src="img/arrow-up.png" alt="Aufsteigend" class="sort-icon up" style="display:none" />
            <img src="img/arrow-down.png" alt="Absteigend" class="sort-icon down" style="display:none" />
          </span>
        </th>
        <th class="header-cell" data-sort-key="Volume">
          <span>Volume</span>
          <span class="sort-icon-container">
            <img src="img/neutral-icon.png" alt="Nicht sortiert" class="sort-icon neutral" />
            <img src="img/arrow-up.png" alt="Aufsteigend" class="sort-icon up" style="display:none" />
            <img src="img/arrow-down.png" alt="Absteigend" class="sort-icon down" style="display:none" />
          </span>
        </th>
        <th class="header-cell">Aktionen</th>
      </tr>
    </thead>
    <tbody>
      <!-- Zeilen werden dynamisch eingefügt -->
    </tbody>
    <tfoot class="table-footer">
      <tr>
        <td colspan="7" class="footer-cell"></td>
      </tr>
    </tfoot>
  </table>

  <!-- Overlay-Box für das Diagramm -->
  <div id="chartOverlay">
    <canvas id="chartCanvas" width="300" height="200"></canvas>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {

      // Globaler Sortier-Zustand – nur eine aktive Spalte.
      let sortState = { key: null, direction: 0 };
      let globalData = [];
      let filteredData = [];

      // JSON-Daten laden; passe den Pfad ggf. an.
      fetch('ipnft_einzelwerte.json')
        .then(response => response.json())
        .then(data => {
          globalData = prepareData(data);
          buildFilterOptions(globalData);
          filteredData = [...globalData];
          renderTable(filteredData);
        })
        .catch(error => console.error('Fehler beim Laden:', error));

      // Datenaufbereitung: Gruppiere Einträge anhand Asset_ID, Category, Monetization und Type.
      // Falls Type fehlt, wird "n/a" gesetzt.
      // Gleichzeitig wird eine revenueSeries (für das Diagramm) erstellt.
      function prepareData(data) {
        const grouped = {};
        data.forEach(record => {
          const typeValue = record.Type ? record.Type : 'n/a';
          const key = record.Asset_ID + '_' + record.Category + '_' + record.Monetization + '_' + typeValue;
          if (!grouped[key]) {
            const revKeys = Object.keys(record).filter(k => k.startsWith('Rev_')).sort();
            let revenueSeries = revKeys.map(k => ({
              date: k.replace('Rev_', ''),
              value: Number(record[k])
            }));
            grouped[key] = {
              Asset_ID: record.Asset_ID,
              Topics: record.Category,
              Monetization: record.Monetization,
              Type: typeValue,
              Start_Date: null,
              Volume: 0,
              revenueSeries: revenueSeries
            };
          }
          const revKeys = Object.keys(record).filter(k => k.startsWith('Rev_')).sort();
          for (let k of revKeys) {
            const val = Number(record[k]);
            if (val > 0) {
              const dateStr = k.replace('Rev_', '');
              if (!grouped[key].Start_Date || dateStr < grouped[key].Start_Date) {
                grouped[key].Start_Date = dateStr;
              }
              break;
            }
          }
          revKeys.forEach(k => {
            grouped[key].Volume += Number(record[k]);
          });
        });
        return Object.values(grouped);
      }

      // Filter-Dropdowns befüllen: Topics, Monetization und Type.
      function buildFilterOptions(data) {
        const topics = [...new Set(data.map(d => d.Topics))].sort();
        const monets = [...new Set(data.map(d => d.Monetization))].sort();
        const types = [...new Set(data.map(d => d.Type))].sort();

        const selectTopic = document.getElementById('filterTopic');
        const selectMonet = document.getElementById('filterMonetization');
        const selectType = document.getElementById('filterType');

        topics.forEach(t => {
          const opt = document.createElement('option');
          opt.value = t;
          opt.textContent = t;
          selectTopic && selectTopic.appendChild(opt);
        });
        monets.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          selectMonet && selectMonet.appendChild(opt);
        });
        types.forEach(tp => {
          const opt = document.createElement('option');
          opt.value = tp;
          opt.textContent = tp;
          selectType && selectType.appendChild(opt);
        });

        if (selectTopic) selectTopic.addEventListener('change', filterAndRender);
        if (selectMonet) selectMonet.addEventListener('change', filterAndRender);
        if (selectType) selectType.addEventListener('change', filterAndRender);

        // Sortier-Event: Jeder Header mit data-sort-key erhält einen Click-Listener.
        document.querySelectorAll('th[data-sort-key]').forEach(th => {
          th.addEventListener('click', () => {
            const key = th.getAttribute('data-sort-key');
            toggleSort(key);
            applySort();
          });
        });
      }

      // Filtert Daten anhand der Dropdown-Werte.
      function filterAndRender() {
        const tVal = document.getElementById('filterTopic').value;
        const mVal = document.getElementById('filterMonetization').value;
        const typeVal = document.getElementById('filterType').value;
        
        filteredData = globalData.filter(d => {
          const topicMatch = !tVal || d.Topics === tVal;
          const monetMatch = !mVal || d.Monetization === mVal;
          const typeMatch = !typeVal || d.Type === typeVal;
          return topicMatch && monetMatch && typeMatch;
        });
        applySort();
      }

      // Toggle-Sortierung: Zyklisch zwischen aufsteigend (1), absteigend (-1) und deaktiviert (0)
      function toggleSort(key) {
        if (sortState.key === key) {
          if (sortState.direction === 1) {
            sortState.direction = -1;
          } else if (sortState.direction === -1) {
            sortState.key = null;
            sortState.direction = 0;
          }
        } else {
          sortState.key = key;
          sortState.direction = 1;
        }
        updateSortIcons();
      }

      // Aktualisiert die Sortier-Icons in den Headern.
      function updateSortIcons() {
        document.querySelectorAll('th[data-sort-key]').forEach(th => {
          const key = th.getAttribute('data-sort-key');
          const neutralIcon = th.querySelector('.sort-icon.neutral');
          const upIcon = th.querySelector('.sort-icon.up');
          const downIcon = th.querySelector('.sort-icon.down');
          if (sortState.key === key) {
            if (sortState.direction === 1) {
              upIcon.style.display = 'inline';
              downIcon.style.display = 'none';
              neutralIcon.style.display = 'none';
            } else if (sortState.direction === -1) {
              downIcon.style.display = 'inline';
              upIcon.style.display = 'none';
              neutralIcon.style.display = 'none';
            }
          } else {
            neutralIcon.style.display = 'inline';
            upIcon.style.display = 'none';
            downIcon.style.display = 'none';
          }
        });
      }

      // Sortiert die gefilterten Daten und rendert die Tabelle.
      function applySort() {
        if (sortState.key && sortState.direction !== 0) {
          filteredData.sort((a, b) => {
            let valA = a[sortState.key];
            let valB = b[sortState.key];
            if (sortState.key === 'Volume') {
              return sortState.direction * (valA - valB);
            } else if (sortState.key === 'Start_Date') {
              if (!valA) return 1;
              if (!valB) return -1;
              return sortState.direction * valA.localeCompare(valB);
            } else {
              return sortState.direction * ('' + valA).localeCompare('' + valB);
            }
          });
        }
        renderTable(filteredData);
      }

      // Baut die Tabelle dynamisch auf.
      function renderTable(data) {
        const tbody = document.querySelector('.data-table tbody');
        if (!tbody) return;
        tbody.innerHTML = '';
        data.forEach(item => {
          const tr = document.createElement('tr');
          tr.classList.add('data-row');
          // Setze einen Asset-Key in der Zeile – zur Identifikation für das Diagramm.
          tr.setAttribute('data-asset-key', item.Asset_ID + '_' + item.Topics + '_' + item.Monetization + '_' + item.Type);
          tr.innerHTML = `
            <td class="content-cell">${item.Asset_ID}</td>
            <td class="content-cell">${item.Type}</td>
            <td class="content-cell">${item.Topics}</td>
            <td class="content-cell">${item.Monetization}</td>
            <td class="content-cell">${item.Start_Date || '---'}</td>
            <td class="content-cell">${item.Volume.toFixed(2)}</td>
            <td class="action-cell">
              <img src="img/icon-eye.png" alt="Diagramm anzeigen" class="action-icon chart-trigger" />
              <img src="img/icon-edit.png" alt="Bearbeiten" class="action-icon" />
              <img src="img/icon-trash.png" alt="Löschen" class="action-icon" />
            </td>
          `;
          tbody.appendChild(tr);
        });
        attachChartEvents();
      }

      // Fügt allen "chart-trigger" Icons Mouseover- und Mouseleave-Events hinzu.
      function attachChartEvents() {
        document.querySelectorAll('.chart-trigger').forEach(icon => {
          icon.addEventListener('mouseover', showChartOverlay);
          icon.addEventListener('mouseleave', hideChartOverlay);
        });
      }

      // Zeigt das Diagramm-Overlay an; positioniert es links von der Maus.
      function showChartOverlay(e) {
        const row = e.target.closest('tr');
        if (!row) return;
        const assetKey = row.getAttribute('data-asset-key');
        const assetData = globalData.find(item => {
          const key = item.Asset_ID + '_' + item.Topics + '_' + item.Monetization + '_' + item.Type;
          return key === assetKey;
        });
        if (!assetData) return;
        const overlay = document.getElementById('chartOverlay');
        const canvas = document.getElementById('chartCanvas');
        const rect = e.target.getBoundingClientRect();
        // Positioniere oberhalb des Overlays (Top) und links von der Maus:
        overlay.style.top = (rect.top + window.scrollY + rect.height + 5) + "px";
        // Hole Overlay-Breite (mit Fallback)
        const overlayWidth = overlay.offsetWidth || 320;
        overlay.style.left = (rect.left + window.scrollX - overlayWidth - 5) + "px";
        overlay.style.display = "block";
        if (window.myChart) window.myChart.destroy();
        const labels = assetData.revenueSeries.map(item => item.date);
        const values = assetData.revenueSeries.map(item => item.value);
        // Berechne kumulative Werte
        let cumulativeValues = [];
        values.forEach((v, i) => {
          cumulativeValues.push(i === 0 ? v : cumulativeValues[i - 1] + v);
        });
        // Erzeuge das Diagramm mit zwei Datensätzen und getrennten y-Achsen:
        window.myChart = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Tageswert',
                data: values,
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1,
                pointRadius: 2,
                yAxisID: 'y'
              },
              {
                label: 'Kumulierte Werte',
                data: cumulativeValues,
                backgroundColor: 'rgba(192, 75, 192, 0.2)',
                borderColor: 'rgba(192, 75, 192, 1)',
                borderWidth: 1,
                pointRadius: 2,
                yAxisID: 'y1'
              }
            ]
          },
          options: {
            scales: {
              y: {
                type: 'linear',
                position: 'left',
                beginAtZero: true,
                title: { display: true, text: 'Tageswert' }
              },
              y1: {
                type: 'linear',
                position: 'right',
                beginAtZero: true,
                grid: { drawOnChartArea: false },
                title: { display: true, text: 'Kumulierte Werte' }
              }
            },
            responsive: false,
            maintainAspectRatio: false
          }
        });
      }

      // Blendet das Diagramm-Overlay wieder aus und zerstört das Chart.
      function hideChartOverlay() {
        const overlay = document.getElementById('chartOverlay');
        overlay.style.display = "none";
        if (window.myChart) {
          window.myChart.destroy();
          window.myChart = null;
        }
      }
      
    });
  </script>
</body>
</html>